package org.example

import java.io.BufferedReader
import java.io.BufferedWriter
import java.io.PrintWriter
import java.net.Socket
import kotlin.concurrent.thread

//управляет сетевым соединением между клиентом и сервером
class Connection {
//Клиент и сервер могут обмениваться данными через сокеты, отправляя и получая потоки байтов.
    private var socket: Socket? = null

    private var pw: PrintWriter? = null

    //Когда сокет устанавливает сетевое соединение между двумя узлами,
    // он создает поток ввода и поток вывода для обмена данными между ними.
    // Поток ввода сокета используется для чтения данных,
    // отправленных удаленным узлом, а поток вывода сокета
    // используется для отправки данных удаленному узлу.
    //объект BufferedReader создается с использованием потока ввода сокета,
    // который получен с помощью метода getInputStream() объекта Socket
    //Поток ввода с буферизацией - это поток ввода, который использует буфер для улучшения
    // производительности чтения данных. Вместо того, чтобы читать данные
    // из источника ввода по одному символу или байту за раз, поток ввода с буферизацией
    // читает данные из источника ввода в блоки, что уменьшает количество обращений
    // к диску или сети и улучшает производительность.
    private var br: BufferedReader? = null

    private var stop = false


    //Когда сервер создает объект Socket для обмена данными с клиентом,
    // этот объект Socket передается в конструктор класса Connection.
    // Внутри класса Connection, этот объект Socket присваивается переменной socket,
    // которая используется для обмена данными с удаленным узлом.
    constructor(socket: Socket) {
        this.socket = socket
    }

    fun start() {

    }

    //через метод println(text) записывается текстовое сообщение в объект PrintWriter,
    // а затем объект PrintWriter отправляет это сообщение по сетевому соединению через
    // поток вывода сокета, полученный с помощью метода getOutputStream()

    //Когда true передается в качестве второго аргумента при создании объекта PrintWriter,
    // это означает, что каждый вызов метода println() будет автоматически вызывать метод
    // flush() на объекте PrintWriter. Метод flush() гарантирует, что все данные,
    // записанные в поток вывода, будут немедленно отправлены по сетевому соединению,
    // а не будут кэшироваться в буфере.
    fun send(text: String) {
        pw = PrintWriter(socket?.getOutputStream(), true)
        pw?.println(text)
    }

//метод receive() класса Connection используется для чтения данных из сетевого соединения.
    fun receive():String? {
        br = socket?.getInputStream()?.bufferedReader()
        return br?.readLine()
    }
//метод finish() класса Connection используется для завершения
// сетевого соединения и освобождения ресурсов, связанных с ним.

//Метод finish() закрывает объекты PrintWriter и BufferedReader,
// которые используются для отправки и получения данных по сетевому соединению.
    fun finish() {
        pw?.close()
        br?.close()
    }

// используется для остановки процесса чтения данных из сетевого соединения.
// Он устанавливает значение переменной stop в true и закрывает объект Socket,
// что приводит к завершению сетевого соединения и освобождению ресурсов, связанных с ним.
    fun stopReceiving() {
        stop = true
        socket?.close()
    }

}